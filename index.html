<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photoshop</title>
    <style>
        *, *::after, *::before {
            margin: 0;
            padding: 0;
        }

        main {
            height: 100vh;
            overflow: hidden;
            background-color: rgb(255, 255, 255);
        }
        .canvas_wrapper {
            display: block;
            width: calc(100% - 95px);
            height: calc(100% - 60px);
            margin: 20px 20px 0px 75px;
            background-color: rgb(45, 45, 45);
            position: relative;
            overflow: hidden;
        }
        .canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .sidebar {
            width: 75px;
            margin-top:40px;
            position: fixed;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .sidebar > li {
            width: 100%;
        }

        img {
            width: 16px;
        }

        .sidebar input {
            position: absolute !important;
            clip: rect(0, 0, 0, 0);
            height: 1px;
            width: 1px;
            border: 0;
            overflow: hidden;
        }

        .sidebar label {
            display: block;
            width: 16px;
            height: 16px;
            background-color: #e4e4e4;
            color: rgba(0, 0, 0, 0.6);
            font-size: 14px;
            line-height: 1;
            text-align: center;
            padding: 8px;
            margin-right: -1px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px rgba(255, 255, 255, 0.1);
            transition: all 0.1s ease-in-out;
        }
        .sidebar label:hover {
            cursor: pointer;
        }

        .sidebar input:checked + label {
            background-color: #a5dc86;
            box-shadow: none;
        }

        p {
            font-weight: bold;
            color: black;
        }
        dialog {
            position: absolute;
            top:50%;
            left:50%;
            transform: translate(-50%, -50%);
            padding: 20px;
        }
        .dialog__content {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #colorWindow {
            position: absolute;
            top: 0;
            right: 0;
            padding: 20px;
            box-shadow: 0 0 10px black;
            z-index: 900;
        }
        #filtration {
            position: absolute;
            top: 0;
            right: 0;
            padding: 20px;
            box-shadow: 0 0 10px black;
            z-index: 900;
            background-color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        #filtration input {
            width: 40px;
        }
        .chart {
            position: absolute;
            top: 0;
            right: 0;
            padding: 20px;
            box-shadow: 0 0 10px black;
            z-index: 900;
            background-color: white;
            width:300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .color__content {
            padding: 10px;
            background-color: white;
            display: flex;
        }
        .color__left, .color__right {
            padding: 10px;
        }
        .square1, .square2 {
            width: 32px;
            height: 32px;
            background-color: black;
        }

        .modal {
            margin-left: 75px;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted black;
        }

        .tooltip-text {
        visibility: hidden;
        width: 200px;
        background-color: #555;
        color: #fff;
        text-align: center;
        padding: 5px;
        position: absolute;
        bottom: 125%;
        margin-left: -160px;
        }

        .tooltip:hover .tooltip-text {
        visibility: visible;
        }
    </style>
</head>
<body>
    <main>
        <div class="modal">
            <label for="imageSelect">Выберите картинку</label>
            <input type="file" id="imageSelect" />
            <input type="text" id="urlInput"/>
            <button id="loadButton">Загрузить по ссылке</button>
            <button id="sizeButton">Изменить размер</button>
            <button id="download">Скачать</button>
        </div>
        <dialog id="dialog">
            <div class="dialog__content">
                <p id="before"></p>
                <p id="after"></p>
                <label for="valueType">Единицы измерения:</label>
                <select id="valueType">
                    <option value="pixels">В пикселях</option>
                    <option value="percent">В процентах</option>
                </select>
                <label for="width">Ширина:</label>
                <input type="number" id="width" min="1">
                <label for="height">Высота:</label>
                <input type="number" id="height" min="1">
                <div>
                    <input type="checkbox" id="maintain-aspect-ratio" checked>
                    <label for="maintain-aspect-ratio">Сохранять пропорции</label>
                </div>
                <label for="interpolationMethod">Алгоритм интерполяции:</label>
                <div>
                    <select id="interpolationMethod">
                        <option value="nearestNeighbor">Ближайший сосед</option>
                    </select>
                    <div class="tooltip">?
                    <div class="tooltip-text">метод интерполяции, при котором в качестве промежуточного значения выбирается ближайшее известное значение</div>
                    </div>
                </div>
                <div>
                    <button id="done">done</button>
                    <button id="close">close</button>
                </div>
            </div>
        </dialog>
        <div id="colorWindow" class="color__content" style="display: none;">
            <div class="color__left" style="border-right: 1px solid black ;">
                <div class="square1" id="square1"></div>
                ЛКМ для выбора
                <p id="infoXsquare1">X: 0</p>
                <p id="infoYsquare1">Y: 0</p><br>
                <p id="infoRsquare1" style="margin-bottom: 10px;">R: 0</p>
                <p id="infoGsquare1" style="margin-bottom: 10px;">G: 0</p>
                <p id="infoBsquare1" style="margin-bottom: 10px;">B: 0</p>
                <p id="contrast">Contrast: ?</p>
            </div>
            <div class="color__right">
                <div class="square2" id="square2"></div>
                CTRL + ЛКМ для выбора
                <p id="infoXsquare2">X: 0</p>
                <p id="infoYsquare2">Y: 0</p><br>
                <p id="infoRsquare2" style="margin-bottom: 10px;">R: 0</p>
                <p id="infoGsquare2" style="margin-bottom: 10px;">G: 0</p>
                <p id="infoBsquare2" style="margin-bottom: 10px;">B: 0</p>
            </div>
            </div>
        </div>
        <div class="chart" id="chartWindow" style="display: none;">
            <label for="x1">X1</label>
            <input id="x1" type="number" value="0" min="0" max="255">
            <label for="y1">Y1</label>
            <input id="y1" type="number" value="0" min="0" max="255">
            <label for="x2">X2</label>
            <input id="x2" type="number" value="255" min="0" max="255">
            <label for="y2">Y2</label>
            <input id="y2" type="number" value="255" min="0" max="255">
            <button id="levelsDone">Применить</button>
            <button id="reset">Сбросить</button>
            <label for="preview">Превью</label>
            <input id="preview" type="checkbox">
            <canvas id="chart" width="300" height="300"></canvas>
        </div>
        <div class="filtration" id="filtration" style="display: none;">
            <select id="filtrationSelect">
                <option value="default">Тождественное отображение</option>
                <option value="sharp">Повышение резкости</option>
                <option value="gauss">Фильтр Гаусса</option>
                <option value="rectangle">Прямоугольное размытие</option>
            </select>
            <div class="row">
                <input class="filtrationInput" type="number" value="0">
                <input class="filtrationInput" type="number" value="0">
                <input class="filtrationInput" type="number" value="0">
            </div>
            <div class="row">
                <input class="filtrationInput" type="number" value="0">
                <input class="filtrationInput" type="number" value="1">
                <input class="filtrationInput" type="number" value="0">
            </div>
            <div class="row">
                <input class="filtrationInput" type="number" value="0">
                <input class="filtrationInput" type="number" value="0">
                <input class="filtrationInput" type="number" value="0">
            </div>
            <label for="filterPreview">Превью</label>
            <input type="checkbox" id="filterPreview">
            <button id="filtrationDone">Применить</button>
        </div>
        <ul class="sidebar" style="list-style: none;">
            <li style="display: flex; flex-direction: column; align-items: center;">
                <p id="infoXfixed">X: 0</p>
                <p id="infoYfixed">Y: 0</p><br>
                <p id="infoRfixed">R: 0</p>
                <p id="infoGfixed">G: 0</p>
                <p id="infoBfixed">B: 0</p>
                <div id="colorSquare" style="width: 0px; height: 0px; border: 16px solid black;"></div>
                <p id="infoX">X: 0</p>
                <p id="infoY">Y: 0</p><br>
                <p id="infoR">R: 0</p>
                <p id="infoG">G: 0</p>
                <p id="infoB">B: 0</p>
            </li>
            <li>
                <div id="controls">
                    <select id="scale-selector">
                        <option value="0.12">12%</option>
                        <option value="0.25">25%</option>
                        <option value="0.5">50%</option>
                        <option value="1" selected>100%</option>
                        <option value="2">200%</option>
                        <option value="3">300%</option>
                    </select>
                </div>
            </li>
            <li>
                <select id="speed">
                    <option value="1" selected>1x</option>
                    <option value="5">5x</option>
                    <option value="10">10x</option>
                </select>
            </li>
            <li>
                <button id="colorButton">Пипетка</button>
            </li>
            <li>
                <button id="levelsButton">Уровни</button>
            </li>
            <li>
                <button id="filtrationButton">Фильтрация</button>
            </li>
        </ul>
        <div id="canvasDomain" class="canvas_wrapper">
            <canvas id="canvas" class="canvas">
            </canvas> 
        </div>    
    </main>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>

        const filtrationButton = document.getElementById("filtrationButton");
        const filtration = document.getElementById("filtration");
        const filtrationDone = document.getElementById("filtrationDone");
        const filtrationInput = document.getElementsByClassName("filtrationInput");
        const filtrationSelect = document.getElementById('filtrationSelect');

        let kernel = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]

        for (let i = 0; i < 9; i++) {
            filtrationInput[i].addEventListener("input", function () {
                kernel[Math.floor(i/3)][i%3] = Number(filtrationInput[i].value);
                if (filterPreview.checked) {
                    filter();
                }
            })
            
        }

        filtrationSelect.addEventListener('change', function() {
            if (filtrationSelect.value == 'default') {
                kernel = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
            }
            if (filtrationSelect.value == 'sharp') {
                kernel = [[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]]
            }
            if (filtrationSelect.value == 'gauss') {
                kernel = [[1, 2, 1], [2, 4, 2], [1, 2, 1]];
            }
            if (filtrationSelect.value == 'rectangle') {
                kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]];
            }
            for (let i = 0; i < 9; i++) {
                filtrationInput[i].value = kernel[Math.floor(i/3)][i%3];
            }
            if (filterPreview.checked) {
                filter();
            }
            
        });

        filtrationButton.addEventListener("click", function() {
            filtration.style.display = filtration.style.display === 'none' ? '' : 'none';
            startImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = startImage.data;
        });

        filtrationDone.addEventListener("click", function() { 
            filter()
            filtration.style.display = filtration.style.display === 'none' ? '' : 'none';
            // console.log(kernel)
        });

        const filterPreview = document.getElementById("filterPreview");
        filterPreview.addEventListener('click', function() {
            if (filterPreview.checked) {
                filter();
            } else {
                ctx.putImageData(startImage, 0, 0)
            }
        })

        function filter() {
            ctx.putImageData(startImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const newData = new Array(imageData.data.length);

            const paddedData = padImageData(imageData.data, imageData.width, imageData.height);

            for (let y = 0; y < imageData.height; y++) {
                for (let x = 0; x < imageData.width; x++) {
                    for (let c = 0; c < 4; c++) {
                        const outputIndex = (y * imageData.width + x) * 4 + c;
                        let sum = 0;
                        let kernelSum = 0;
                        for (let ky = 0; ky < 3; ky++) {
                            for (let kx = 0; kx < 3; kx++) {
                                const inputIndex =
                                ((y + ky) * (imageData.width + 2) + (x + kx)) * 4 + c;
                                sum += paddedData[inputIndex] * kernel[ky][kx];
                                kernelSum += kernel[ky][kx];
                            }
                        }
                        newData[outputIndex] = sum / kernelSum;
                    }
                }
            }

            imageData.data.set(newData);
            ctx.putImageData(imageData, 0, 0);
            }



            function padImageData(data, width, height) {
                const paddedWidth = width + 2;
                const paddedHeight = height + 2;
                const paddedData = new Uint8ClampedArray(paddedWidth * paddedHeight * 4);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                    const inputIndex = (y * width + x) * 4;
                    const outputIndex = ((y + 1) * paddedWidth + x + 1) * 4;
                    paddedData.set(
                        data.subarray(inputIndex, inputIndex + 4),
                        outputIndex
                    );
                    }
                }

                for (let y = 0; y < paddedHeight; y++) {
                    for (let x = 0; x < paddedWidth; x++) {
                    const outputIndex = (y * paddedWidth + x) * 4;
                    if ( x === 0 || x === paddedWidth - 1 || y === 0 || y === paddedHeight - 1) {
                        const nearestX = Math.max(1, Math.min(x, paddedWidth - 2));
                        const nearestY = Math.max(1, Math.min(y, paddedHeight - 2));
                        const nearestIndex = (nearestY * paddedWidth + nearestX) * 4;
                        paddedData.set(
                        paddedData.subarray(nearestIndex, nearestIndex + 4),
                        outputIndex
                        );
                    }
                    }
                }
                return paddedData;
                }



        let canvas = document.getElementById("canvas");
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const canvasDomain = document.getElementById("canvasDomain");

        var img = new Image();
        img.crossOrigin = 'anonymous';
        let scale = 1;
        const loadButton = document.getElementById("loadButton");
        const urlInput = document.getElementById("urlInput");

        loadButton.addEventListener("click", function() {
            img.src = urlInput.value;
            canvas.width = img.width;
            canvas.height = img.height;
            canvas.style.removeProperty("width");
            canvas.style.removeProperty("height");
            ctx.drawImage(img, 0, 0);
            if (canvas.width > canvas.height) {
                canvas.style.width = canvasDomain.offsetWidth - 100 + 'px';
            } else {
                canvas.style.height = canvasDomain.offsetHeight - 100 + 'px';
            }
        })

        //Color picker
        const colorSquare = document.getElementById('colorSquare')
        canvas.addEventListener('mousemove', function(event) {
            var x = event.clientX - canvas.getBoundingClientRect().left;
            var y = event.clientY - canvas.getBoundingClientRect().top;
            var pixel = ctx.getImageData(canvas.width*(x)/canvas.offsetWidth, canvas.height*(y)/canvas.offsetHeight, 1, 1).data;

            var color = 'rgb(' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ')';
            infoX.textContent = 'X: ' + Math.ceil(canvas.width*(x)/canvas.offsetWidth);
            infoY.textContent = 'Y: ' + Math.ceil(canvas.height*(y)/canvas.offsetHeight);
            infoR.textContent = 'R: ' + pixel[0];
            infoG.textContent = 'G: ' + pixel[1];
            infoB.textContent = 'B: ' + pixel[2];
            colorSquare.style.borderBottomColor = color;
            colorSquare.style.borderRightColor = color;
        });

        function getRGB(color) {
            var match = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/.exec(color);
            return match ? {
                r: parseInt(match[1]),
                g: parseInt(match[2]),
                b: parseInt(match[3])
            } : null;
        }

        function rgbToXyz(R, G, B) {
            var_R = parseFloat( R / 255 )        //R from 0 to 255
            var_G = parseFloat( G / 255 )        //G from 0 to 255
            var_B = parseFloat( B / 255 )        //B from 0 to 255

            if ( var_R > 0.04045 ) {
                var_R = Math.pow(( ( var_R + 0.055 ) / 1.055 ), 2.4)
            }
            else { 
                var_R = var_R / 12.92
            }
            if ( var_G > 0.04045 ) { 
                var_G = Math.pow(( ( var_G + 0.055 ) / 1.055 ), 2.4)
            }
            else {
                var_G = var_G / 12.92
            }
            if ( var_B > 0.04045 ) {
                 var_B = Math.pow(( ( var_B + 0.055 ) / 1.055 ), 2.4)
            }
            else {                   
                var_B = var_B / 12.92
            }

            var_R = var_R * 100
            var_G = var_G * 100
            var_B = var_B * 100

            X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805
            Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722
            Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505
            return [X, Y, Z]
        }

        function rgbToLab(r, g, b) {
            var r = r / 255,
                g = g / 255,
                b = b / 255,
                x, y, z;

            r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
            y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
            z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;

            x = (x > 0.008856) ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
            y = (y > 0.008856) ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
            z = (z > 0.008856) ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

            return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)]
        }

        function getContrastRatio(color1, color2) {
            var rgb1 = getRGB(color1);
            var rgb2 = getRGB(color2);

            var brightness1 = getRelativeLuminance(rgb1);
            var brightness2 = getRelativeLuminance(rgb2);

            // Рассчитываем контрастность по формуле WCAG
            var contrastRatio = (brightness1 + 0.05) / (brightness2 + 0.05);

            return contrastRatio;
        }

        function getRelativeLuminance(rgb) {
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;

            var R = RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            var G = GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            var B = BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4);

            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        }

        canvas.addEventListener('click', function(event) {
            var x = event.clientX - canvas.getBoundingClientRect().left;
            var y = event.clientY - canvas.getBoundingClientRect().top;

            var pixel = ctx.getImageData(canvas.width*(x)/canvas.offsetWidth, canvas.height*(y)/canvas.offsetHeight, 1, 1).data;

            var color = 'rgb(' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ')';
            infoXfixed.textContent = 'X: ' + Math.ceil(canvas.width*(x)/canvas.offsetWidth);
            infoYfixed.textContent = 'Y: ' + Math.ceil(canvas.height*(y)/canvas.offsetHeight);
            infoRfixed.textContent = 'R: ' + pixel[0];
            infoGfixed.textContent = 'G: ' + pixel[1];
            infoBfixed.textContent = 'B: ' + pixel[2];
            colorSquare.style.borderTopColor = color;
            colorSquare.style.borderLeftColor = color;



            if (!event.ctrlKey) {
                var x = event.clientX - canvas.getBoundingClientRect().left;
                var y = event.clientY - canvas.getBoundingClientRect().top;

                var pixel = ctx.getImageData(canvas.width*(x)/canvas.offsetWidth, canvas.height*(y)/canvas.offsetHeight, 1, 1).data;

                var color = 'rgb(' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ')';
                infoXsquare1.textContent = 'X: ' + Math.ceil(canvas.width*(x)/canvas.offsetWidth);
                infoYsquare1.textContent = 'Y: ' + Math.ceil(canvas.height*(y)/canvas.offsetHeight);
                infoRsquare1.textContent = 'RGB: ' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2];
                infoGsquare1.textContent = 'XYZ: ' + rgbToXyz(pixel[0],pixel[1],pixel[2]).map(n => " "+Math.round(n * 100) / 100 +'%');
                infoBsquare1.textContent = 'Lab: ' + rgbToLab(pixel[0],pixel[1],pixel[2]).map(n => " "+Math.round(n * 100) / 100 +'');
                square1.style.backgroundColor = color;
                contrast.textContent = 'Contrast: ' + Math.round(getContrastRatio(square1.style.backgroundColor, square2.style.backgroundColor), 2);
                if (Math.round(getContrastRatio(square1.style.backgroundColor, square2.style.backgroundColor)*100)/100 < 4.5) {
                    contrast.style.color = 'rgb(255,0,0)';
                } else {
                    contrast.style.color = 'rgb(0,0,0)';
                }
            }

            if (event.ctrlKey) {
                var x = event.clientX - canvas.getBoundingClientRect().left;
                var y = event.clientY - canvas.getBoundingClientRect().top;

                var pixel = ctx.getImageData(canvas.width*(x)/canvas.offsetWidth, canvas.height*(y)/canvas.offsetHeight, 1, 1).data;

                var color = 'rgb(' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ')';
                infoXsquare2.textContent = 'X: ' + Math.ceil(canvas.width*(x)/canvas.offsetWidth);
                infoYsquare2.textContent = 'Y: ' + Math.ceil(canvas.height*(y)/canvas.offsetHeight);
                infoRsquare2.textContent = 'RGB: ' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2];
                infoGsquare2.textContent = 'XYZ: ' + rgbToXyz(pixel[0],pixel[1],pixel[2]).map(n => " "+Math.round(n * 100) / 100 +'%');
                infoBsquare2.textContent = 'Lab: ' + rgbToLab(pixel[0],pixel[1],pixel[2]).map(n => " "+Math.round(n * 100) / 100 +'');
                square2.style.backgroundColor = color;
                contrast.textContent = 'Contrast: ' + Math.round(getContrastRatio(square1.style.backgroundColor, square2.style.backgroundColor)*100)/100;
                if (Math.round(getContrastRatio(square1.style.backgroundColor, square2.style.backgroundColor)*100)/100 < 4.5) {
                    contrast.style.color = 'rgb(255,0,0)';
                } else {
                    contrast.style.color = 'rgb(0,0,0)';
                }
            // console.log(square1.style.backgroundColor, square2.style.backgroundColor)
            }
        });
        // LAB 4
        const levelsButton = document.getElementById('levelsButton');
        const chartWindow = document.getElementById('chartWindow');

        const chart = document.getElementById("chart");
        const chartctx = chart.getContext('2d');

        const x1 = document.getElementById('x1');
        const y1 = document.getElementById('y1');
        const x2 = document.getElementById('x2');
        const y2 = document.getElementById('y2');

        const preview = document.getElementById('preview');

        [x1, y1, x2, y2].forEach((n) => n.addEventListener('change', function() {
            chartInstance.data.datasets[3].data = [
                { x: 0, y: parseInt(y1.value) },
                { x: parseInt(x1.value), y: parseInt(y1.value) },
                { x: parseInt(x2.value), y: parseInt(y2.value) },
                { x: 255, y: parseInt(y2.value) }]
            if (preview.checked) {
                drawImage();
            }
            chartInstance.update();
        }))

        preview.addEventListener('click', function() {
            if (preview.checked) {
                drawImage();
            } else {
                ctx.putImageData(startImage, 0, 0)
            }
        })
        

        let startImage = null

        levelsButton.addEventListener('click', function() {
            chartWindow.style.display = chartWindow.style.display === 'none' ? '' : 'none';

            startImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = startImage.data;

            console.log(data)

            let redChannel = new Array(256).fill(0);
            let greenChannel = new Array(256).fill(0);
            let blueChannel = new Array(256).fill(0);

            for (let i = 0; i < data.length; i += 4) {
                let red = data[i];
                let green = data[i + 1];
                let blue = data[i + 2];
                redChannel[red]++;
                greenChannel[green]++;
                blueChannel[blue]++;
            }

            redChannel = normalizeHistogram(redChannel);
            greenChannel = normalizeHistogram(greenChannel);
            blueChannel = normalizeHistogram(blueChannel);

            drawHistograms(redChannel, greenChannel, blueChannel)
        });

        function normalizeHistogram(histogram) {
            const max = Math.max(...histogram);
            return histogram.map((value) => (value / max) * 255);
            }

        
        let chartInstance = null;

        function drawHistograms(redHistogram, greenHistogram, blueHistogram) {
            if (chartInstance) {
                chartInstance.destroy();
            }

            console.log(x1.value, y1.value, x2.value, y2.value)
        chartInstance = new Chart(chartctx, {
        type: "line",
        data: {
          labels: Array.from({ length: 256 }, (_, i) => i),
          datasets: [
            {
              label: "Red",
              data: redHistogram,
              backgroundColor: "rgba(255, 0, 0, 0.8)",
            },
            {
              label: "Green",
              data: greenHistogram,
              backgroundColor: "rgba(0, 255, 0, 0.8)",
            },
            {
              label: "Blue",
              data: blueHistogram,
              backgroundColor: "rgba(0, 0, 255, 0.8)",
            },
            {
              label: "line",
              data: [
                { x: 0, y: parseInt(y1.value) },
                { x: parseInt(x1.value), y: parseInt(y1.value) },
                { x: parseInt(x2.value), y: parseInt(y2.value) },
                { x: 255, y: parseInt(y2.value) },
              ],
              borderColor: "rgba(0,0,0,1)",
              borderWidth: 1,
              fill: false,
            },
          ],
        },
        options: {
          animation: false,
          scales: {
            x: {
                type: "linear",
                position: "bottom",
                min: 0,
                max: 260,
                ticks: {
                    stepSize: 15,
                },
            },
            y: {
                beginAtZero: true,
                min: 0,
                max: 260,
                ticks: {
                    stepSize: 15,
                },
            },
          },
        },
      });
    }

    const levelsDone = document.getElementById("levelsDone");

    levelsDone.addEventListener("click", () => {drawImage(); chartWindow.style.display = chartWindow.style.display === 'none' ? '' : 'none';
        x1.value = 0;
        x2.value = 255;
        y1.value = 0;
        y2.value = 255;
        chartInstance.data.datasets[3].data = [
                { x: 0, y: parseInt(y1.value) },
                { x: parseInt(x1.value), y: parseInt(y1.value) },
                { x: parseInt(x2.value), y: parseInt(y2.value) },
                { x: 255, y: parseInt(y2.value) }]
        chartInstance.update()
    });

    const reset = document.getElementById("reset");

    reset.addEventListener("click", function(e) {
        ctx.putImageData(startImage, 0, 0);
        x1.value = 0;
        x2.value = 255;
        y1.value = 0;
        y2.value = 255;
        chartInstance.data.datasets[3].data = [
                { x: 0, y: parseInt(y1.value) },
                { x: parseInt(x1.value), y: parseInt(y1.value) },
                { x: parseInt(x2.value), y: parseInt(y2.value) },
                { x: 255, y: parseInt(y2.value) }]
        chartInstance.update()
    });

    function drawImage() {
      ctx.putImageData(startImage, 0, 0);
      let lut = [];
      for (let i = 0; i < parseInt(x1.value); i++) {
        lut[i] = parseInt(y1.value);
      }
      for (let i = parseInt(x1.value); i < parseInt(x2.value); i++) {
        const slope = (parseInt(y2.value) - parseInt(y1.value)) / (parseInt(x2.value) - parseInt(x1.value));
        let correctedValue = parseInt(y1.value) + slope * (i - parseInt(x1.value));
        correctedValue = Math.max(0, Math.min(255, correctedValue));
        lut[i] = correctedValue;
      }
      for (let i = x2.value; i < 256; i++) {
        lut[i] = parseInt(y2.value);
      }
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        data[i] = lut[data[i]];
        data[i + 1] = lut[data[i + 1]];
        data[i + 2] = lut[data[i + 2]];
      }
      ctx.putImageData(imageData, 0, 0);
    }


        //Mover
        var step = 1;
        const speed = document.getElementById('speed');
        speed.addEventListener('change', function() {
            step = parseFloat(speed.value);
        });
        document.addEventListener("DOMContentLoaded", function() {

            var topPosition = 50;
            var leftPosition = 50;

            function handleKeyPress(event) {
                switch(event.keyCode) {
                    case 37: // Стрелка влево
                        leftPosition = Math.max(leftPosition - step, 0);
                        break;
                    case 38: // Стрелка вверх
                        topPosition = Math.max(topPosition - step, 0);
                        break;
                    case 39: // Стрелка вправо
                        leftPosition = Math.min(leftPosition + step, 100);
                        break;
                    case 40: // Стрелка вниз
                        topPosition = Math.min(topPosition + step, 100);
                        break;
                }
                canvas.style.top = topPosition + "%";
                canvas.style.left = leftPosition + "%";
            }

            document.addEventListener("keydown", handleKeyPress);
        });

        //Color Picker v2

        const colorButton = document.getElementById("colorButton");
        const colorWindow = document.getElementById('colorWindow');

        var infoXsquare1 = document.getElementById("infoXsquare1");
        var infoYsquare1 = document.getElementById("infoYsquare1");
        var infoRsquare1 = document.getElementById("infoRsquare1");
        var infoGsquare1 = document.getElementById("infoGsquare1");
        var infoBsquare1 = document.getElementById("infoBsquare1");

        var infoXsquare2 = document.getElementById("infoXsquare2");
        var infoYsquare2 = document.getElementById("infoYsquare2");
        var infoRsquare2 = document.getElementById("infoRsquare2");
        var infoGsquare2 = document.getElementById("infoGsquare2");
        var infoBsquare2 = document.getElementById("infoBsquare2");

        var square1 = document.getElementById("square1");
        var square2 = document.getElementById('square2');

        contrast = document.getElementById('contrast');

        colorButton.addEventListener('click', function() {
            colorWindow.style.display = colorWindow.style.display === 'none' ? '' : 'none';
        });


        // Scale
        const scaleSelector = document.getElementById('scale-selector');

        scaleSelector.addEventListener('change', function() {
            const scale = parseFloat(scaleSelector.value);
            scaleImage(scale);
        });

        function scaleImage(factor) {
            canvas.style.removeProperty("width");
            canvas.style.removeProperty("height");
            if (canvas.width > canvas.height) {
                canvas.style.width = factor*(canvasDomain.offsetWidth - 100) + 'px';
            } else {
                canvas.style.height = factor*(canvasDomain.offsetHeight) - 100 + 'px';
            }
        }

        //Interpolation
        const scaleButton = document.getElementById('sizeButton');
        const dialog = document.getElementById('dialog');
        const done = document.getElementById('done');
        const close = document.getElementById('close');
        const width = document.getElementById('width');
        const height = document.getElementById('height');
        const download = document.getElementById('download');
        const maintain = document.getElementById('maintain-aspect-ratio')
        let ratio = width.value / height.value

        scaleButton.addEventListener('click', function() {
            console.log(img.width, img.height);
            width.value = img.width
            height.value = img.height
            ratio = width.value / height.value
            before.textContent = "Было: " + ((canvas.width * canvas.height) / 1000000).toFixed(2) + ' Мегапикселей'
            after.textContent = "Стало: " + ((canvas.width * canvas.height) / 1000000).toFixed(2) + ' Мегапикселей'
            dialog.showModal()
        });

        const valueType = document.getElementById('valueType');

        valueType.addEventListener('change', function() {
            if (valueType.value == 'pixels') {
                width.value = img.width
                height.value = img.height
            }
            if (valueType.value == 'percent') {
                width.value = 100
                height.value = 100
            }
        });

        width.addEventListener('input', function() {
            after.textContent = "Стало: " + ((width.value * height.value) / 1000000).toFixed(2) + ' Мегапикселей'
            if (maintain.checked) {
                height.value = Math.round(width.value / ratio)
                if (valueType.value == 'percent') {
                    height.value = width.value
                }
            }
        })

        height.addEventListener('input', function() {
            after.textContent = "Стало: " + ((width.value * height.value) / 1000000).toFixed(2) + ' Мегапикселей'
            if (maintain.checked) {
                width.value = Math.round(height.value * ratio)
                if (valueType.value == 'percent') {
                    width.value = height.value
                }
            }
        })

        done.addEventListener('click', function() {
            // Интерполяция
            dialog.close()
            const originCanvas = document.createElement('canvas')
            const originCtx = originCanvas.getContext('2d');
            originCanvas.width = img.width;
            originCanvas.height = img.height;
            originCtx.drawImage(img, 0, 0, originCanvas.width, originCanvas.height);
            const originalImageData = ctx.getImageData(0, 0, originCanvas.width, originCanvas.height);

            const helpCanvas = document.createElement('canvas')
            const helpCtx = helpCanvas.getContext('2d');
            if (valueType.value == 'percent') {
                helpCanvas.width = img.width * width.value / 100;
                helpCanvas.height = img.height * height.value / 100;
            }
            if (valueType.value == 'pixels') {
                helpCanvas.width = width.value;
                helpCanvas.height = height.value;
            }
            const newImageData = helpCtx.createImageData(helpCanvas.width, helpCanvas.height);

            for (let y = 0; y < helpCanvas.height; y++) {
                for (let x = 0; x < helpCanvas.width; x++) {
                    const originalX = Math.round(x * (originCanvas.width / helpCanvas.width));
                    const originalY = Math.round(y * (originCanvas.height / helpCanvas.height));

                    const index = (originalY * originalImageData.width + originalX) * 4;
                    const r = originalImageData.data[index];
                    const g = originalImageData.data[index + 1];
                    const b = originalImageData.data[index + 2];
                    const a = originalImageData.data[index + 3];

                    const newIndex = (y * newImageData.width + x) * 4;
                    newImageData.data[newIndex] = r;
                    newImageData.data[newIndex + 1] = g;
                    newImageData.data[newIndex + 2] = b;
                    newImageData.data[newIndex + 3] = a;
                }
                }
                helpCtx.putImageData(newImageData,0 ,0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                canvas.width = helpCanvas.width;
                canvas.height = helpCanvas.height;
                ctx.putImageData(newImageData, 0, 0);
                img.src = helpCanvas.toDataURL()
        });
        close.addEventListener('click', function() {
            dialog.close()
        })

        //Download
        download.addEventListener('click', function() {
            var link = document.createElement('a');
            link.download = 'filename.png';
            link.href = canvas.toDataURL()
            link.click();
        });


        
        // const originCanvas = document.createElement('canvas');
        // const originCtx = originCanvas.getContext('2d');
        // originCanvas.width = img.width;
        // originCanvas.height = img.height;
        // originCtx.drawImage(img, 0, 0, originCanvas.width, originCanvas.height);
        // const originalImageData = ctx.getImageData(0, 0, originCanvas.width, originCanvas.height);
        // document.body.appendChild(originCanvas);
        

        // var canvas = document.getElementById("canvas");

        // var infoX = document.getElementById("infoX");
        // var infoY = document.getElementById("infoY");
        // var infoR = document.getElementById("infoR");
        // var infoG = document.getElementById("infoG");
        // var infoB = document.getElementById("infoB");

        // var infoXfixed = document.getElementById("infoXfixed");
        // var infoYfixed = document.getElementById("infoYfixed");
        // var infoRfixed = document.getElementById("infoRfixed");
        // var infoGfixed = document.getElementById("infoGfixed");
        // var infoBfixed = document.getElementById("infoBfixed");

        // var ctx = canvas.getContext("2d" , { willReadFrequently: true });
        // var colorSquare = document.getElementById("color")

        // var loadButton = document.getElementById("loadButton");
        // var urlInput = document.getElementById("urlInput");

        // var before = document.getElementById("before");
        // var after = document.getElementById("after");

        // const colorButton = document.getElementById("colorButton");
        // const colorWindow = document.getElementById('colorWindow');

        // colorButton.addEventListener('click', function() {
        //     colorWindow.style.display = colorWindow.style.display === 'none' ? '' : 'none';
        // });

        // var img = new Image()
        // img.crossOrigin = 'anonymous'
        
        // img.onload = function() {
        //     var widthScale = (canvas.width - 100) / img.width;
        //     var heightScale = (canvas.height - 100) / img.height;
        //     var scale = Math.min(widthScale, heightScale);
        //     ctx.clearRect(0, 0, canvas.width, canvas.height);
        //     ctx.drawImage(img, Math.max(50, (canvas.width - img.width * scale)/2), Math.max(50, (canvas.height - img.height * scale)/2), img.width * scale, img.height * scale);
        // }

        // loadButton.addEventListener("click", function() {
        //     img.src = urlInput.value;
        // })

        // const scaleSelector = document.getElementById('scale-selector');

        // scaleSelector.addEventListener('change', function() {
        //     const scale = parseFloat(scaleSelector.value);
        //     scaleImage(scale);
        // });

        // function scaleImage(factor) {
        //     var widthScale = (canvas.width - 100) / img.width;
        //     var heightScale = (canvas.height - 100) / img.height;
        //     var scale = Math.min(widthScale, heightScale) * factor;
        //     ctx.clearRect(0, 0, canvas.width, canvas.height);
        //     ctx.drawImage(img, Math.max(50, (canvas.width - img.width * scale)/2), Math.max(50, (canvas.height - img.height * scale)/2), img.width * scale, img.height * scale);
        // }   

        // const scaleButton = document.getElementById('sizeButton');
        // const dialog = document.getElementById('dialog');
        // const done = document.getElementById('done');
        // const close = document.getElementById('close');
        // const width = document.getElementById('width');
        // const height = document.getElementById('height');
        // const download = document.getElementById('download');
        // const maintain = document.getElementById('maintain-aspect-ratio')
        // let ratio = width.value / height.value

        // download.addEventListener('click', function() {
        //     var link = document.createElement('a');
        //     link.download = 'filename.png';
        //     const originCanvas = document.createElement('canvas')
        //     const originCtx = originCanvas.getContext('2d');
        //     originCanvas.width = img.width;
        //     originCanvas.height = img.height;
        //     originCtx.drawImage(img, 0, 0);
        //     document.body.appendChild(originCanvas);
        //     link.href = originCanvas.toDataURL()
        //     link.click();
        //     document.body.removeChild(originCanvas);
        // });

        // const valueType = document.getElementById('valueType');

        // valueType.addEventListener('change', function() {
        //     if (valueType.value == 'pixels') {
        //         width.value = img.width
        //         height.value = img.height
        //     }
        //     if (valueType.value == 'percent') {
        //         width.value = 100
        //         height.value = 100
        //     }
        // })

        // scaleButton.addEventListener('click', function() {
        //     console.log(img.width, img.height);
        //     width.value = img.width
        //     height.value = img.height
        //     ratio = width.value / height.value
        //     before.textContent = "Было: " + ((img.width * img.height) / 1000000).toFixed(2) + ' Мегапикселей'
        //     after.textContent = "Стало: " + ((img.width * img.height) / 1000000).toFixed(2) + ' Мегапикселей'
        //     dialog.showModal()
        // });

        // width.addEventListener('input', function() {
        //     after.textContent = "Стало: " + ((width.value * height.value) / 1000000).toFixed(2) + ' Мегапикселей'
        //     if (maintain.checked) {
        //         height.value = Math.round(width.value / ratio)
        //         if (valueType.value == 'percent') {
        //             height.value = width.value
        //         }
        //     }
        // })

        // height.addEventListener('input', function() {
        //     after.textContent = "Стало: " + ((width.value * height.value) / 1000000).toFixed(2) + ' Мегапикселей'
        //     if (maintain.checked) {
        //         width.value = Math.round(height.value * ratio)
        //         if (valueType.value == 'percent') {
        //             width.value = height.value
        //         }
        //     }
        // })

        // done.addEventListener('click', function() {
        //     // Интерполяцияяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяя
        //     dialog.close()
        //     const originCanvas = document.createElement('canvas')
        //     const originCtx = originCanvas.getContext('2d');
        //     originCanvas.width = img.width;
        //     originCanvas.height = img.height;
        //     originCtx.drawImage(img, 0, 0, originCanvas.width, originCanvas.height);
        //     const originalImageData = ctx.getImageData(0, 0, originCanvas.width, originCanvas.height);

        //     const helpCanvas = document.createElement('canvas')
        //     const helpCtx = helpCanvas.getContext('2d');
        //     if (valueType.value == 'percent') {
        //         helpCanvas.width = img.width * width.value / 100;
        //         helpCanvas.height = img.height * height.value / 100;
        //     }
        //     if (valueType.value == 'pixels') {
        //         helpCanvas.width = width.value;
        //         helpCanvas.height = height.value;
        //     }
        //     const newImageData = helpCtx.createImageData(helpCanvas.width, helpCanvas.height);

        //     for (let y = 0; y < helpCanvas.height; y++) {
        //         for (let x = 0; x < helpCanvas.width; x++) {
        //             const originalX = Math.round(x * (originCanvas.width / helpCanvas.width));
        //             const originalY = Math.round(y * (originCanvas.height / helpCanvas.height));

        //             const index = (originalY * originalImageData.width + originalX) * 4;
        //             const r = originalImageData.data[index];
        //             const g = originalImageData.data[index + 1];
        //             const b = originalImageData.data[index + 2];
        //             const a = originalImageData.data[index + 3];

        //             const newIndex = (y * newImageData.width + x) * 4;
        //             newImageData.data[newIndex] = r;
        //             newImageData.data[newIndex + 1] = g;
        //             newImageData.data[newIndex + 2] = b;
        //             newImageData.data[newIndex + 3] = a;
        //         }
        //         }
        //         helpCtx.putImageData(newImageData,0 ,0);
        //         ctx.clearRect(0, 0, canvas.width, canvas.height);
        //         ctx.putImageData(newImageData, Math.max(50, (canvas.width - newImageData.width)/2), Math.max(50, (canvas.height - newImageData.height)/2));
        //         img.src = helpCanvas.toDataURL()
        // });
        // close.addEventListener('click', function() {
        //     dialog.close()
        // })
        
        // //img.src = "https://helpx.adobe.com/content/dam/help/en/photoshop/using/convert-color-image-black-white/jcr_content/main-pars/before_and_after/image-before/Landscape-Color.jpg"
        
        // // img.onload = function () {
        // //     var widthScale = canvas.width / img.width;
        // //     var heightScale = canvas.height / img.height;
        // //     var scale = Math.min(widthScale, heightScale);
            
        // //     ctx.drawImage(img, 0, 0, img.width * scale, img.height * scale);
        // // }

        
        // document.getElementById('imageSelect').addEventListener('change', handleFileImage, false);

        // function handleFileImage(e) {
        //     var img = new Image()
        //     img.crossOrigin = 'anonymous'
        //     img.onload = function() {
        //         var widthScale = canvas.width / img.width;
        //         var heightScale = canvas.height / img.height;
        //         var scale = Math.min(widthScale, heightScale);
        //         ctx.clearRect(0, 0, canvas.width, canvas.height);
        //         ctx.drawImage(img, 0, 0, img.width * scale, img.height * scale);
        //     }
        //     img.src = URL.createObjectURL(e.target.files[0]);
        // }

        // //console.log(canvas.width, canvas.clientWidth, img.width, img.clientWidth)
        // canvas.width = canvas.clientWidth
        // canvas.height = canvas.clientHeight
        // canvas.addEventListener('mousemove', function(event) {
        //     var x = event.clientX - canvas.getBoundingClientRect().left;
        //     var y = event.clientY - canvas.getBoundingClientRect().top;

        //     var pixel = ctx.getImageData(x, y, 1, 1).data;

        //     var color = 'rgb(' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ')';

        //     infoX.textContent = 'X: ' + x;
        //     infoY.textContent = 'Y: ' + Math.ceil(y);
        //     infoR.textContent = 'R: ' + pixel[0];
        //     infoG.textContent = 'G: ' + pixel[1];
        //     infoB.textContent = 'B: ' + pixel[2];
        //     colorSquare.style.borderBottomColor = color;
        //     colorSquare.style.borderRightColor = color;
        // });
        // canvas.addEventListener('click', function(event) {
        //     var x = event.clientX - canvas.getBoundingClientRect().left;
        //     var y = event.clientY - canvas.getBoundingClientRect().top;

        //     var pixel = ctx.getImageData(x, y, 1, 1).data;

        //     var color = 'rgb(' + pixel[0] + ', ' + pixel[1] + ', ' + pixel[2] + ')';
        //     infoXfixed.textContent = 'X: ' + x;
        //     infoYfixed.textContent = 'Y: ' + Math.ceil(y);
        //     infoRfixed.textContent = 'R: ' + pixel[0];
        //     infoGfixed.textContent = 'G: ' + pixel[1];
        //     infoBfixed.textContent = 'B: ' + pixel[2];
        //     colorSquare.style.borderTopColor = color;
        //     colorSquare.style.borderLeftColor = color;
        // });
    </script>
</body>
</html>